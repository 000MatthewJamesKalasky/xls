// Copyright 2020 The XLS Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/container/flat_hash_map.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/types/span.h"
#include "xls/common/file/filesystem.h"
#include "xls/common/init_xls.h"
#include "xls/common/logging/logging.h"
#include "xls/common/status/status_macros.h"
#include "xls/fuzzer/sample_summary.pb.h"
#include "xls/ir/op.h"

const char kUsage[] = R"(
Reads Protobuf summary files emitted by the fuzzer and presents the data in
tabular form. The summary information includes information about each IR sample
generated by the fuzzer including op types, widths, etc. This information gives
an indication of what kind of IR operations are being covered by the
fuzzer. Usage:

  read_summary_main  [SUMMARY_FILE...]

Example invocations:

Show summary of a set of files emitted by the fuzzer:

  read_summary_main /tmp/summaries/summary_*.binarypb
)";

namespace xls {
namespace {

struct OpInfo {
  // Count of the number of instances of this op.
  int64 samples;

  // Count of operations by type ("bits", "array", or "tuple").
  absl::flat_hash_map<std::string, int64> by_type;

  // Count of operations wider than 64 bits.
  int64 wider_than_64bits;

  // Count of operations for which the operands are different widths.
  int64 mixed_width;

  // Count of operations with different arities.
  int64 nullary;
  int64 unary;
  int64 binary;
  int64 manyary;
};

struct SummaryInfo {
  int64 samples;
  absl::flat_hash_map<std::string, OpInfo> op_info;
};

void AggregateSummary(const fuzzer::SampleSummaryProto& summary,
                      SummaryInfo* info) {
  info->samples++;
  for (const fuzzer::NodeProto& node_proto : summary.nodes()) {
    OpInfo& op_info = info->op_info[node_proto.op()];
    op_info.samples++;
    op_info.by_type[node_proto.type()]++;
    if (node_proto.width() > 64) {
      op_info.wider_than_64bits++;
    }
    switch (node_proto.operands_size()) {
      case 0:
        op_info.nullary++;
        break;
      case 1:
        op_info.unary++;
        break;
      case 2:
        op_info.binary++;
        break;
      default:
        op_info.manyary++;
        break;
    }
    for (const fuzzer::NodeProto& operand : node_proto.operands()) {
      if (operand.width() != node_proto.operands(0).width()) {
        op_info.mixed_width++;
        break;
      }
    }
  }
}

void DumpSummaryInfo(const SummaryInfo& info) {
  std::cout << absl::StreamFormat("Sample count: %d\n", info.samples);
  auto fmt = [&](const std::string& s, bool first_col = false) {
    if (first_col) {
      return absl::StrFormat("%-20s", s);
    } else {
      return absl::StrFormat("%13s", s);
    }
  };
  auto fmt_num = [&](int64 n) { return fmt(absl::StrCat(n), false); };

  std::vector<std::string> fields{"op",    "count",    "bits",        "tuple",
                                  "array", ">64-bits", "mixed width", "nullary",
                                  "unary", "binary",   ">=3ary"};
  for (int64 i = 0; i < fields.size(); ++i) {
    std::cout << fmt(fields[i], /*first_col=*/i == 0);
  }
  std::cout << "\n" << std::string(20 + 13 * (fields.size() - 1), '-') << "\n";
  for (Op op : AllOps()) {
    std::string op_str = OpToString(op);
    OpInfo op_info =
        info.op_info.contains(op_str) ? info.op_info.at(op_str) : OpInfo{0};
    std::cout << fmt(op_str, /*first_col=*/true);
    std::cout << fmt_num(op_info.samples);
    std::cout << fmt_num(op_info.by_type["bits"]);
    std::cout << fmt_num(op_info.by_type["tuple"]);
    std::cout << fmt_num(op_info.by_type["array"]);
    std::cout << fmt_num(op_info.wider_than_64bits);
    std::cout << fmt_num(op_info.mixed_width);
    std::cout << fmt_num(op_info.nullary);
    std::cout << fmt_num(op_info.unary);
    std::cout << fmt_num(op_info.binary);
    std::cout << fmt_num(op_info.manyary);
    std::cout << "\n";
  }
}

absl::Status RealMain(absl::Span<const absl::string_view> input_paths) {
  std::map<std::string, SummaryInfo> infos;
  for (const absl::string_view input_path : input_paths) {
    XLS_ASSIGN_OR_RETURN(std::string summary_data, GetFileContents(input_path));
    fuzzer::SampleSummaries summaries;
    if (!summaries.ParseFromString(summary_data)) {
      return absl::DataLossError("Failed to parse summary protobuf file.");
    }
    for (const fuzzer::SampleSummaryProto& summary : summaries.samples()) {
      AggregateSummary(summary, &infos[summary.tag()]);
    }
  }

  for (const auto& pair : infos) {
    const std::string& tag = pair.first;
    const SummaryInfo& info = pair.second;

    std::cout << absl::StreamFormat("\nTag: \"%s\"\n", tag);
    DumpSummaryInfo(info);
  }
  return absl::OkStatus();
}

}  // namespace
}  // namespace xls

int main(int argc, char** argv) {
  std::vector<absl::string_view> positional_arguments =
      xls::InitXls(kUsage, argc, argv);

  if (positional_arguments.empty()) {
    XLS_LOG(QFATAL) << absl::StreamFormat(
        "Expected invocation: %s [SUMMARY_FILE...]", argv[0]);
  }

  XLS_QCHECK_OK(xls::RealMain(positional_arguments));
  return EXIT_SUCCESS;
}
