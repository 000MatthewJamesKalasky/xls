# Copyright 2021 The XLS Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""A script for testing the translated IR for individual C++ functions.

Uses a standard C++ compiler as a reference.

The target function is instrumented using a RAII mechanism to capture its
inputs and outputs. The instrumentation is generated according to information
in the metadata protobuf generated by xlscc.

When the modified C++ binary is run, the instrumentation code writes inputs to
one file, and expected outputs into another. These files, together with the IR
from xlscc, are fed into the eval_ir_main tool, which checks that the results
of IR simulation match the expected values file generated by the C++ binary.
"""

import os
import shutil
import subprocess
import tempfile
import textwrap

from absl import app
from absl import flags

from xls.common import runfiles
from xls.contrib.xlscc import metadata_output_pb2

FLAGS = flags.FLAGS

flags.DEFINE_string("ir_to_test", None, "Path to IR file to test")
flags.mark_flag_as_required("ir_to_test")
flags.DEFINE_string("xlscc_metadata", None,
                    "Path to metadata protobuf from xlscc")
flags.mark_flag_as_required("xlscc_metadata")
flags.DEFINE_string("cmd_to_test", None, "Command to generate traces")
flags.mark_flag_as_required("cmd_to_test")
flags.DEFINE_string("build_cmd", None, "Command to build the C binary used")
flags.mark_flag_as_required("build_cmd")
flags.DEFINE_string(
    "function_to_instrument", None,
    "Simple name of function to instrument. Defaults to top function from MetadataOutput"
)
flags.mark_flag_as_required("function_to_instrument")

EVAL_IR_PATH = runfiles.get_path("xls/tools/eval_ir_main")


def find_offset_for_loc(src: str, loc: metadata_output_pb2.SourceLocation):
  """Find the linear index for a file + line location.

  Args:
    src: Source to search
    loc: Location to find

  Returns:
    Integer index of loc
  """
  offset = 0
  line = 1
  col = 1

  for offset in range(len(src)):
    if src[offset] == "\n":
      line += 1
      col = 1
      continue

    if (line == loc.line) and (col == loc.column):
      return offset

    col += 1

  raise app.Error("Failed to find offset for {loc}".format(loc=loc))


def get_func_to_instrument(
    meta_proto: metadata_output_pb2.MetadataOutput,
    function_to_instrument_name: str) -> metadata_output_pb2.FunctionPrototype:
  """Gets the metadata for the target function to be instrumented.

  Args:
    meta_proto: Protobuf from xlscc describing all the translated IR
    function_to_instrument_name: Simple name of the function (not fully
      qualified)

  Returns:
    Protobuf describing the target function for instrumentation
  """
  if function_to_instrument_name is None:
    top_func_meta = meta_proto.top_func_proto
    assert not top_func_meta
    function_to_instrument_name = top_func_meta.name.name

  filtered_funcs = [
      f for f in meta_proto.all_func_protos
      if f.name.name == function_to_instrument_name
  ]

  if not filtered_funcs:
    raise app.Error("Couldn't find metadata for function with name: {n}".format(
        n=function_to_instrument_name))

  if len(filtered_funcs) > 1:
    raise app.Error("Found more than one function with name: {n}".format(
        n=function_to_instrument_name))

  return filtered_funcs[0]


def template_arg_to_string(arg: metadata_output_pb2.TemplateArgument) -> str:
  """Converts a template argument in the metadata protobuf to a C++ type name.

  Args:
    arg: Protobuf describing the argument

  Returns:
    The formatted C++ argument
  """
  if arg.HasField("as_integral"):
    return "{n}".format(n=arg.as_integral.real)
  elif arg.HasField("as_type"):
    return type_to_string(arg.as_type)
  else:
    raise app.Error(
        "Don't know how to translate template: {arg}".format(arg=arg))


def type_to_string(type_pb: metadata_output_pb2.Type) -> str:
  """Converts a type as specified in the metadata protobuf to a C++ type name.

  Args:
    type_pb: Protobuf describing the type

  Returns:
    The formatted C++ type name
  """
  if type_pb.HasField("as_void"):
    return "void"
  if type_pb.HasField("as_int"):
    ret = ""
    if not type_pb.as_int.is_signed:
      ret += "unsigned "
    if type_pb.as_int.width == 8:
      ret += "char"
    elif type_pb.as_int.width == 16:
      ret += "short"
    elif type_pb.as_int.width == 32:
      ret += "int"
    elif type_pb.as_int.width == 64:
      ret += "long"
    else:
      raise app.Error(
          "Don't know how to translate native int of width: {w}".format(
              w=type_pb.as_int.width))

    return ret
  elif type_pb.HasField("as_inst"):
    ret = type_pb.as_inst.name.fully_qualified_name
    if type_pb.as_inst.args:
      ret += "<"
      ret += ", ".join(map(template_arg_to_string, type_pb.as_inst.args))
      ret += ">"
    return ret
  elif type_pb.HasField("as_array"):
    ret = type_to_string(type_pb.as_array.element_type)
    ret += "[{n}]".format(n=type_pb.as_array.size)
    return ret
  else:
    raise app.Error(
        "Don't know how to translate type: {t}".format(t=type_pb.as_int.width))


def find_instantiated_type(
    id_pb: int,
    metadata: metadata_output_pb2.MetadataOutput) -> metadata_output_pb2.Type:
  """Finds a type by id in the metadata protobuf.

  Args:
    id_pb: Id number of the type
    metadata: Protobuf from xlscc describing all the translated IR

  Returns:
    The protobuf describing the type identified by id_pb
  """
  for record in metadata.structs:
    if not record.HasField("as_struct"):
      raise app.Error("Non-struct type in structs field")

    struct = record.as_struct
    assert struct.name.HasField("as_inst")
    if struct.name.as_inst.name.id == id_pb:
      return record

  raise app.Error(
      "Couldn't find instantiated type with id: {id}".format(id=id_pb))


def format_print_value(name: str, stream_name: str,
                       type_pb: metadata_output_pb2.Type,
                       metadata: metadata_output_pb2.MetadataOutput) -> str:
  """Formats C++ source to print out a value.

  Args:
    name: Name of the value in the C++ source
    stream_name: Name of the stream to print to, such as cout
    type_pb: Protobuf describing the type of the value
    metadata: Protobuf from xlscc describing all the translated IR

  Returns:
    The formatted C++ source
  """
  if type_pb.HasField("as_bits"):
    return "    {stream_name}<<\"bits[{w}]:\"<<{v};".format(
        stream_name=stream_name, w=type_pb.as_bits.width, v=name)
  elif type_pb.HasField("as_int"):
    return "    {stream_name}<<\"bits[{w}]:\"<<{v};".format(
        stream_name=stream_name, w=type_pb.as_int.width, v=name)
  elif type_pb.HasField("as_inst"):
    return format_print_value(
        name, stream_name,
        find_instantiated_type(type_pb.as_inst.name.id, metadata), metadata)
  elif type_pb.HasField("as_struct"):
    if type_pb.as_struct.no_tuple:
      assert 1 == len(type_pb.as_struct.fields)
      one_field = type_pb.as_struct.fields[0]
      return format_print_value(name, stream_name, one_field.type, metadata)
    else:

      def format_field(field: metadata_output_pb2.StructField):
        return format_print_value(name + "." + field.name, stream_name,
                                  field.type, metadata)

      ret = "{stream_name}<<\"(\";\n".format(stream_name=stream_name)
      ret += "{stream_name}<<\",\";\n".format(stream_name=stream_name).join(
          map(format_field, type_pb.as_struct.fields))
      ret += "{stream_name}<<\")\";\n".format(stream_name=stream_name)
      return ret
  elif type_pb.HasField("as_array"):
    ret = "{stream_name}<<\"[\";\n".format(stream_name=stream_name)
    elems = []
    for i in range(type_pb.as_array.size):
      elems += [
          format_print_value("{n}[{i}]".format(n=name, i=i), stream_name,
                             type_pb.as_array.element_type, metadata)
      ]
    ret += "{stream_name}<<\",\";\n".format(stream_name=stream_name).join(elems)
    ret += "{stream_name}<<\"]\";\n".format(stream_name=stream_name)
    return ret
  else:
    raise app.Error("Unimplemented print for type {t}".format(t=type_pb))


def instrument_source(
    function_to_instrument_proto: metadata_output_pb2.FunctionPrototype,
    inputs_path: str, outputs_path: str, original_src_tmp: str,
    metadata: metadata_output_pb2.MetadataOutput) -> str:
  """Modifies source file to instrument the target function.

  Args:
    function_to_instrument_proto: Protobuf describing the target function
    inputs_path: File path where the test binary should write the input values
    outputs_path: File path where the test binary should write the output values
    original_src_tmp: File path at which to save the unmodified C++ source file
    metadata: Protobuf from xlscc describing all the translated IR

  Returns:
    The path to the C++ file that was modified
  """

  filename_to_modify = function_to_instrument_proto.return_location.begin.filename

  shutil.copyfile(filename_to_modify, original_src_tmp)

  src = None
  with open(filename_to_modify, "r") as f:
    orig_src = f.read()

  params_end_loc = find_offset_for_loc(
      orig_src, function_to_instrument_proto.parameters_location.end)

  decl_begin_loc = find_offset_for_loc(
      orig_src, function_to_instrument_proto.whole_declaration_location.begin)

  decl_end_loc = find_offset_for_loc(
      orig_src, function_to_instrument_proto.whole_declaration_location.end)

  open_brace_loc = orig_src.find("{", params_end_loc)
  assert open_brace_loc >= 0

  saved_refs_src = ""
  params_srcs = []
  init_srcs = []
  call_constructor_src = []
  enter_print_srcs = []
  exit_print_srcs = []

  if not function_to_instrument_proto.return_type.HasField("as_void"):
    exit_print_srcs += [
        format_print_value("instrument__retval", "outputs_str",
                           function_to_instrument_proto.return_type, metadata)
    ]

  for param in function_to_instrument_proto.params:
    if param.type.HasField(
        "as_inst"
    ) and param.type.as_inst.name.fully_qualified_name == "__xls_channel":
      raise app.Error(
          "Channel parameters unsupported for {t}".format(t=param.name))

    param_decl = ""
    if param.is_const:
      param_decl += "const "

    if not param.type.HasField("as_array"):
      param_decl += type_to_string(param.type)
      param_decl += "& " + param.name
    else:
      element_type = param.type.as_array.element_type
      param_decl += "{type} (&{name})[{n}]".format(
          type=type_to_string(element_type),
          name=param.name,
          n=param.type.as_array.size)

    params_srcs += [param_decl]

    call_constructor_src += [param.name]

    enter_print_srcs += [
        format_print_value(param.name, "inputs_str", param.type, metadata)
    ]

    if param.is_reference and not param.is_const:
      saved_refs_src += "  "
      saved_refs_src += param_decl
      saved_refs_src += ";\n"
      init_srcs += [param.name + "(" + param.name + ")"]
      exit_print_srcs += [
          format_print_value(param.name, "outputs_str", param.type, metadata)
      ]

  exit_print_src = ""
  assert exit_print_srcs
  if len(exit_print_srcs) > 1:
    exit_print_src = "outputs_str<<\"(\";\n" + "outputs_str<<\", \";\n".join(
        exit_print_srcs) + "\noutputs_str<<\")\";\n"
  else:
    exit_print_src = exit_print_srcs[0]

  enter_print_src = ""
  assert enter_print_srcs
  if len(enter_print_srcs) > 1:
    enter_print_src = "inputs_str<<\"; \";\n".join(enter_print_srcs)
  else:
    enter_print_src = enter_print_srcs[0]

  return_stuff = ""

  if not function_to_instrument_proto.return_type.HasField("as_void"):
    return_stuff = textwrap.dedent("""
                      {return_type} instrument__retval;
                      template<typename T>
                      T operator=(const T& op) {{
                        instrument__retval = static_cast<{return_type}>(op);
                        return op;
                      }}
""").format(
    return_type=type_to_string(function_to_instrument_proto.return_type))

  before_func_src = textwrap.dedent("""
                      #include <fstream>
                      static std::ofstream inputs_str("{in_path}");
                      static std::ofstream outputs_str("{out_path}");

                      class capture_return {{
                       private:

                      {saved_refs}
                       public:
                        capture_return({params})
                         {inits} {{
                      {enter_print_src}
                          inputs_str << std::endl;
                        }}
                        ~capture_return() {{
                      {exit_print_src}
                          outputs_str << std::endl;
                        }}

                        {return_stuff}
                      }};

""").format(
    params=", ".join(params_srcs),
    inits=(": " + ", ".join(init_srcs)) if init_srcs else "",
    saved_refs=saved_refs_src,
    enter_print_src=enter_print_src,
    exit_print_src=exit_print_src,
    return_stuff=return_stuff,
    in_path=inputs_path,
    out_path=outputs_path)

  instrument_src = textwrap.dedent("""
                    capture_return capture_return_i ({call_constructor_src});

                    #define return return capture_return_i =
  """).format(call_constructor_src=", ".join(call_constructor_src))

  src = orig_src

  src = src[:decl_begin_loc] + before_func_src + src[decl_begin_loc + 0:]

  open_brace_loc += len(before_func_src)
  decl_end_loc += len(before_func_src)

  src = src[:open_brace_loc + 1] + instrument_src + src[open_brace_loc + 2:]
  decl_end_loc += len(instrument_src)

  src = src[:decl_end_loc] + "\n" + "#undef return" + "\n" + src[decl_end_loc +
                                                                 0:]

  top_hdr = textwrap.dedent("""
#define XlsInt ac_int
""")

  src = top_hdr + src

  with open(filename_to_modify, "w") as f:
    f.write(src)

  return filename_to_modify


def main(argv):
  if len(argv) > 1:
    raise app.UsageError("Too many command-line arguments.")

  # Parse metadata
  meta_proto = metadata_output_pb2.MetadataOutput()
  with open(FLAGS.xlscc_metadata, "rb") as f:
    meta_proto.ParseFromString(f.read())

  # Find function to instrument
  function_to_instrument_proto = get_func_to_instrument(
      meta_proto, FLAGS.function_to_instrument)

  # Instrument C source
  original_src_tmp = tempfile.NamedTemporaryFile(suffix=".cc")
  inputs_tmp = tempfile.NamedTemporaryFile(suffix=".ir")
  outputs_tmp = tempfile.NamedTemporaryFile(suffix=".ir")

  print("Saving original source before instrumentation at ",
        original_src_tmp.name)
  filename_to_modify = instrument_source(function_to_instrument_proto,
                                         inputs_tmp.name, outputs_tmp.name,
                                         original_src_tmp.name, meta_proto)

  assert 0 == os.path.getsize(inputs_tmp.name)
  assert 0 == os.path.getsize(outputs_tmp.name)

  # Build the C model
  print("Building C++ binary...")
  subprocess.check_call(FLAGS.build_cmd, shell=True)

  # Revert C source
  print("Reverting C++ source...")
  shutil.copyfile(original_src_tmp.name, filename_to_modify)

  # Run C model to generate traces
  print("Running C++ binary...")
  subprocess.check_call(FLAGS.cmd_to_test, shell=True)

  assert 0 < os.path.getsize(inputs_tmp.name)
  assert 0 < os.path.getsize(outputs_tmp.name)

  # Run IR simulator
  # check_output to suppress the spammy output of eval_ir_main
  print("Running IR simulator...")
  subprocess.check_output([
      EVAL_IR_PATH, "--entry", function_to_instrument_proto.name.xls_name,
      "--input_file", inputs_tmp.name, "--expected_file", outputs_tmp.name,
      FLAGS.ir_to_test
  ])

  # Done! If we got here, then there were no errors or mismatches
  print("... Success!")


if __name__ == "__main__":
  app.run(main)
